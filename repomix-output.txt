This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-12T13:18:12.098Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
cmd/
  api/
    main.go
internal/
  config/
    config.go
  constants/
    auth_message.go
    campaign_message.go
    cart_message.go
    cartItem_message.go
    category_message.go
    error_message.go
    product_message.go
    user_message.go
  delivery/
    http/
      handler/
        auth_handler.go
        campaign_handler.go
        cart_handler.go
        cartItem_handler.go
        category_handler.go
        handler.go
        product_handler.go
      middleware/
        auth_middileware.go
        middleware.go
      response/
        response.go
      routes/
        route.go
  domain/
    campaigns.go
    cart.go
    cartItem.go
    category.go
    error.go
    product.go
    user.go
  repository/
    mongodb/
      campaign_repository.go
      cart_repository.go
      cartItem_repository.go
      category_repository.go
      product_repository.go
      user_repository.go
    repository.go
  usecase/
    auth_usecase.go
    campaign_usecase.go
    cart_usecase.go
    cartItem_usecase.go
    category_usecase_test.go
    category_usecase.go
    product_usecase.go
pkg/
  mongodb/
    mongodb.go
  validator/
    validator.go
.gitignore
go.mod
go.sum

================================================================
Repository Files
================================================================

================
File: cmd/api/main.go
================
package main

import (
	"context"
	"log"
	"play-to-win-api/internal/config"
	"play-to-win-api/internal/delivery/http/handler"
	"play-to-win-api/internal/delivery/http/middleware"
	route "play-to-win-api/internal/delivery/http/routes"
	"play-to-win-api/internal/repository/mongodb"
	"play-to-win-api/internal/usecase"
	mongoClient "play-to-win-api/pkg/mongodb"
	"play-to-win-api/pkg/validator"
	"time"

	"github.com/labstack/echo/v4"
)

func main() {

	cfg := config.LoadConfig()

	if cfg.JWT.AccessSecret == "" || cfg.JWT.RefreshSecret == "" {
		log.Fatal("JWT secrets must be configured")
	}

	db, err := mongoClient.NewClient(
		context.Background(),
		cfg.MongoDB.URI,
		cfg.MongoDB.Database,
	)
	if err != nil {
		log.Fatal("Failed to connect to MongoDB:", err)
	}

	categoryRepo := mongodb.NewCategoryRepository(db)
	userRepo := mongodb.NewUserRepository(db)
	productRepo := mongodb.NewProductRepository(db)
	campaignRepo := mongodb.NewCampaignRepository(db)
	cartRepo := mongodb.NewCartRepository(db)
	cartItemRepo := mongodb.NewCartItemRepository(db)

	categoryUseCase := usecase.NewCategoryUseCase(categoryRepo)
	authUseCase := usecase.NewAuthUseCase(
		userRepo,
		cfg.JWT.AccessSecret,
		cfg.JWT.RefreshSecret,
		24*time.Hour,
		7*24*time.Hour,
	)
	productUseCase := usecase.NewProductUseCase(productRepo)
	campaignUseCase := usecase.NewCampaignUseCase(campaignRepo)
	cartUseCase := usecase.NewCartUseCase(cartRepo)
	cartItemUseCase := usecase.NewCartItemUseCase(cartItemRepo)

	e := echo.New()

	v := validator.NewValidator()

	authMiddleware := middleware.NewAuthMiddleware(cfg.JWT.AccessSecret)

	handlers := &handler.Handlers{
		Category: handler.NewCategoryHandler(categoryUseCase),
		Auth:     handler.NewAuthHandler(authUseCase, v),
		AuthMW:   authMiddleware,
		Product:  handler.NewProductHandler(productUseCase),
		Campaign: handler.NewCampaignHandler(campaignUseCase),
		Cart:     handler.NewCartHandler(cartUseCase, authUseCase),
		CartItem: handler.NewCartItemHandler(cartItemUseCase),
	}

	route.SetupRoutes(e, handlers)

	if err := e.Start(":" + cfg.Server.Port); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}

================
File: internal/config/config.go
================
package config

import (
	"log"
	"os"
	"time"

	"github.com/joho/godotenv"
)

type Config struct {
	Server  ServerConfig
	MongoDB MongoDBConfig
	JWT     JWTConfig
}

type ServerConfig struct {
	Port         string
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

type MongoDBConfig struct {
	URI      string
	Database string
	Timeout  time.Duration
}

type JWTConfig struct {
	AccessSecret     string
	RefreshSecret    string
	AccessExpiresIn  time.Duration
	RefreshExpiresIn time.Duration
}

func LoadConfig() *Config {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found. Using system environment variables.")
	}

	return &Config{
		Server: ServerConfig{
			Port:         getEnv("SERVER_PORT", "8081"),
			ReadTimeout:  time.Second * 15,
			WriteTimeout: time.Second * 15,
		},
		MongoDB: MongoDBConfig{
			URI:      getEnv("MONGODB_URI", "http://localhost:27017"),
			Database: getEnv("MONGODB_DATABASE", "play-to-win-db"),
			Timeout:  time.Second * 10,
		},
		JWT: JWTConfig{
			AccessSecret:     getEnv("ACCESS_SECRET", "access_secret"),
			RefreshSecret:    getEnv("REFRESH_SECRET", "refresh_secret"),
			AccessExpiresIn:  time.Hour * 24,
			RefreshExpiresIn: time.Hour * 24 * 7,
		},
	}
}

func getEnv(key, defaultValue string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return defaultValue
}

================
File: internal/constants/auth_message.go
================
package constants

const (
	RegistrationSuccess = "User registered successfully"
	LoginSuccess        = "User logged in successfully"
	RefreshSuccess      = "Token refreshed successfully"
	ProfileSuccess      = "User profile retrieved successfully"

	RegistrationError  = "Failed to register user"
	LoginError         = "Failed to login user"
	RefreshError       = "Failed to refresh token"
	ProfileError       = "Failed to retrieve user profile"
	InvalidCredentials = "Invalid credentials"
	InvalidToken       = "Invalid token"
	InvalidUserClaims  = "Invalid user claims"

	MissingAuthHeader    = "Missing authorization header"
	InvalidAuthHeader    = "Invalid authorization header"
	InsufficientPerms    = "Insufficient permissions"
	NotAuthenticated     = "User not authenticated"
)

================
File: internal/constants/campaign_message.go
================
package constants

const (
	CampaignCreatedSuccess    = "Campaign created successfully"
	CampaignUpdatedSuccess    = "Campaign updated successfully"
	CampaignDeletedSuccess    = "Campaign deleted successfully"
	CampaignRetrievedSuccess  = "Campaign retrieved successfully"
	CampaignsRetrievedSuccess = "Campaigns retrieved successfully"

	CampaignNotFoundError    = "Campaign not found"
	CampaignCreateError      = "Failed to create campaign"
	CampaignUpdateError      = "Failed to update campaign"
	CampaignDeleteError      = "Failed to delete campaign"
	CampaignInvalidIDError   = "Invalid campaign ID"
	CampaignInvalidDataError = "Invalid campaign data"
	CampaignDuplicateError   = "Campaign already exists"
)

================
File: internal/constants/cart_message.go
================
package constants

const (
	CartCreatedSuccess    = "Cart has been created"
	CartUpdatedSuccess    = "Cart has been updated"
	CartDeletedSuccess    = "Cart has been deleted"
	CartRetrievedSuccess  = "Cart has been retrieved"
	CartsRetrievedSuccess = "Carts have been retrieved"

	CartCreateError = "Error while creating cart"
	CartUpdateError = "Error while updating cart"
	CartDeleteError = "Error while deleting cart"
	CartNotFound    = "Cart not found"
	CartError       = "Error while processing cart"
)

================
File: internal/constants/cartItem_message.go
================
package constants

const (
	CartItemCreatedSuccess    = "Cart Item has been created"
	CartItemUpdatedSuccess    = "Cart Item has been updated"
	CartItemDeletedSuccess    = "Cart Item has been deleted"
	CartItemRetrievedSuccess  = "Cart Item has been retrieved"
	CartItemsRetrievedSuccess = "Cart Items have been retrieved"

	CartItemCreateError = "Error while creating cart item"
	CartItemUpdateError = "Error while updating cart item"
	CartItemDeleteError = "Error while deleting cart item"
	CartItemNotFound    = "Cart item not found"
	CartItemError       = "Error while processing cart item"
)

================
File: internal/constants/category_message.go
================
package constants

const (
	CategoryCreatedSuccess     = "Category created successfully"
	CategoryUpdatedSuccess     = "Category updated successfully"
	CategoryDeletedSuccess     = "Category deleted successfully"
	CategoryRetrievedSuccess   = "Category retrieved successfully"
	CategoriesRetrievedSuccess = "Categories retrieved successfully"

	CategoryNotFoundError    = "Category not found"
	CategoryCreateError      = "Failed to create category"
	CategoryUpdateError      = "Failed to update category"
	CategoryDeleteError      = "Failed to delete category"
	CategoryInvalidIDError   = "Invalid category ID"
	CategoryInvalidDataError = "Invalid category data"
	CategoryDuplicateError   = "Category already exists"
)

================
File: internal/constants/error_message.go
================
package constants

const (
	StatusSuccess       = 200
	StatusCreated       = 201
	StatusBadRequest    = 400
	StatusNotFound      = 404
	StatusInternalError = 500
)

const (
	DatabaseError       = "Database operation failed"
	InvalidRequestError = "Invalid request payload"
	InternalServerError = "Internal server error"
)

================
File: internal/constants/product_message.go
================
package constants

const (
	ProductCreatedSuccess    = "Product created successfully"
	ProductUpdatedSuccess    = "Product updated successfully"
	ProductDeletedSuccess    = "Product deleted successfully"
	ProductRetrievedSuccess  = "Product retrieved successfully"
	ProductsRetrievedSuccess = "Products retrieved successfully"

	ProductNotFoundError    = "Product not found"
	ProductCreateError      = "Failed to create product"
	ProductUpdateError      = "Failed to update product"
	ProductDeleteError      = "Failed to delete product"
	ProductInvalidIDError   = "Invalid product ID"
	ProductInvalidDataError = "Invalid product data"
	ProductDuplicateError   = "Product already exists"
)

================
File: internal/constants/user_message.go
================
package constants

const (
	UserCreatedSuccess    = "User created successfully"
	UserUpdatedSuccess    = "User updated successfully"
	UserDeletedSuccess    = "User deleted successfully"
	UserRetrievedSuccess  = "User retrieved successfully"
	UsersRetrievedSuccess = "Users retrieved successfully"

	UserNotFoundError    = "User not found"
	UserCreateError      = "Failed to create user"
	UserUpdateError      = "Failed to update user"
	UserDeleteError      = "Failed to delete user"
	UserInvalidIDError   = "Invalid user ID"
	UserInvalidDataError = "Invalid user data"
	UserDuplicateError   = "User already exists"
)

================
File: internal/delivery/http/handler/auth_handler.go
================
package handler

import (
	"net/http"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/middleware"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
)

type AuthHandler struct {
	validator   *validator.CustomValidator
	authUseCase domain.AuthUseCase
}

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
}

func NewAuthHandler(uc domain.AuthUseCase, validator *validator.CustomValidator) AuthHandler {
	return AuthHandler{
		validator:   validator,
		authUseCase: uc,
	}
}

func (h *AuthHandler) Register(c echo.Context) error {
	var user domain.User
	if err := c.Bind(&user); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidCredentials)
	}

	if err := h.validator.Validate(&user); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, err.Error())
	}

	tokens, err := h.authUseCase.Register(c.Request().Context(), &user)
	if err != nil {
		switch err {
		case domain.ErrUserAlreadyExists:
			return response.ErrorResponse(c, http.StatusConflict, constants.UserDuplicateError)
		default:
			return response.ErrorResponse(c, http.StatusInternalServerError, constants.RegistrationError)
		}
	}

	return response.NewResponse(c, http.StatusCreated, constants.RegistrationSuccess, tokens)
}

func (h *AuthHandler) Login(c echo.Context) error {

	var credentials struct {
		Email    string `json:"email" validate:"required,email"`
		Password string `json:"password" validate:"required"`
	}

	if err := c.Bind(&credentials); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	if err := h.validator.Validate(&credentials); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, err.Error())
	}

	tokens, err := h.authUseCase.Login(c.Request().Context(), credentials.Email, credentials.Password)
	if err != nil {
		return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidCredentials)
	}

	return response.NewResponse(c, http.StatusOK, constants.LoginSuccess, tokens)
}

func (h *AuthHandler) RefreshToken(c echo.Context) error {
	var req struct {
		RefreshToken string `json:"refresh_token" validate:"required"`
	}

	if err := c.Bind(&req); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	tokens, err := h.authUseCase.RefreshToken(c.Request().Context(), req.RefreshToken)
	if err != nil {
		return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidToken)
	}

	return response.NewResponse(c, http.StatusOK, constants.RefreshSuccess, tokens)
}

func (h *AuthHandler) GetProfile(c echo.Context) error {
	claims, ok := c.Get("user").(*middleware.Claims)
	if !ok {
		return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidUserClaims)
	}

	user, err := h.authUseCase.GetUserByEmail(c.Request().Context(), claims.Email)

	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, constants.UserNotFoundError)
	}

	profile, err := h.authUseCase.GetProfile(c.Request().Context(), user.ID.Hex())

	if err != nil {
		if err == domain.ErrUserNotFound {
			return response.ErrorResponse(c, http.StatusNotFound, constants.UserNotFoundError)
		}
		return response.ErrorResponse(c, http.StatusInternalServerError, constants.ProfileError)
	}

	return response.NewResponse(c, http.StatusOK, constants.UserRetrievedSuccess, profile)
}

================
File: internal/delivery/http/handler/campaign_handler.go
================
package handler

import (
	"net/http"
	"time"

	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type CampaignHandler struct {
	BaseHandler
	campaignUseCase domain.CampaignUseCase
}

func NewCampaignHandler(uc domain.CampaignUseCase) CampaignHandler {
	return CampaignHandler{
		BaseHandler:     BaseHandler{validator: validator.NewValidator()},
		campaignUseCase: uc,
	}
}

func (h *CampaignHandler) Create(c echo.Context) error {
	var campaign domain.Campaign
	if err := c.Bind(&campaign); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	campaign.IsActive = true
	campaign.StartDate = time.Now()
	campaign.EndDate = time.Now().AddDate(0, 0, 7)

	if err := h.campaignUseCase.Create(c.Request().Context(), &campaign); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusCreated, constants.CampaignCreatedSuccess, campaign)
}

func (h *CampaignHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	campaign, err := h.campaignUseCase.GetByID(c.Request().Context(), id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CampaignRetrievedSuccess, campaign)
}

func (h *CampaignHandler) GetAll(c echo.Context) error {
	campaigns, err := h.campaignUseCase.GetAll(c.Request().Context())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CampaignsRetrievedSuccess, campaigns)
}

func (h *CampaignHandler) Update(c echo.Context) error {
	id := c.Param("id")
	var campaign domain.Campaign
	if err := c.Bind(&campaign); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	objectID, err := primitive.ObjectIDFromHex(id)

	if err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.CampaignInvalidDataError)
	}

	campaign.ID = objectID
	if err := h.campaignUseCase.Update(c.Request().Context(), &campaign); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CampaignUpdatedSuccess, campaign)
}

func (h *CampaignHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.campaignUseCase.Delete(c.Request().Context(), id); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CampaignDeletedSuccess, nil)
}

================
File: internal/delivery/http/handler/cart_handler.go
================
package handler

import (
	"net/http"
	"time"

	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/middleware"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
)

type CartHandler struct {
	BaseHandler
	cartUseCase  domain.CartUseCase
	authUserCase domain.AuthUseCase
}

func NewCartHandler(uc domain.CartUseCase, ac domain.AuthUseCase) CartHandler {
	return CartHandler{
		BaseHandler:  BaseHandler{validator: validator.NewValidator()},
		cartUseCase:  uc,
		authUserCase: ac,
	}
}

func (h *CartHandler) Create(c echo.Context) error {
	claims, ok := c.Get("user").(*middleware.Claims)
	if !ok {
		return response.ErrorResponse(c, http.StatusInternalServerError, constants.InternalServerError)
	}

	user, err := h.authUserCase.GetUserByEmail(c.Request().Context(), claims.Email)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	var cart domain.Cart
	if err := c.Bind(&cart); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	cart.User = *user
	cart.CreatedAt = time.Now()
	cart.UpdatedAt = time.Now()

	if err := h.cartUseCase.Create(c.Request().Context(), &cart); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusCreated, constants.CartCreatedSuccess, cart)
}

func (h *CartHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	cart, err := h.cartUseCase.GetByID(c.Request().Context(), id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartRetrievedSuccess, cart)
}

func (h *CartHandler) GetByUserID(c echo.Context) error {
	claims, ok := c.Get("user").(*middleware.Claims)

	user, err := h.authUserCase.GetUserByEmail(c.Request().Context(), claims.Email)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	if !ok {
		return response.ErrorResponse(c, http.StatusInternalServerError, constants.InternalServerError)
	}

	cart, err := h.cartUseCase.GetByUserID(c.Request().Context(), user.ID.Hex())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartRetrievedSuccess, cart)
}

func (h *CartHandler) GetAll(c echo.Context) error {
	carts, err := h.cartUseCase.GetAll(c.Request().Context())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartRetrievedSuccess, carts)
}

func (h *CartHandler) Update(c echo.Context) error {
	var cart domain.Cart
	if err := c.Bind(&cart); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	if err := h.cartUseCase.Update(c.Request().Context(), &cart); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartUpdatedSuccess, cart)
}

func (h *CartHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.cartUseCase.Delete(c.Request().Context(), id); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartDeletedSuccess, nil)
}

================
File: internal/delivery/http/handler/cartItem_handler.go
================
package handler

import (
	"net/http"
	"time"

	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
)

type CartItemHandler struct {
	BaseHandler
	cartItemUseCase domain.CartItemUseCase
}

func NewCartItemHandler(uc domain.CartItemUseCase) CartItemHandler {
	return CartItemHandler{
		BaseHandler:     BaseHandler{validator: validator.NewValidator()},
		cartItemUseCase: uc,
	}
}

func (h *CartItemHandler) Create(c echo.Context) error {
	var cartItem domain.CartItem
	if err := c.Bind(&cartItem); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	cartItem.CreatedAt = time.Now()
	cartItem.UpdatedAt = time.Now()

	if err := h.cartItemUseCase.Create(c.Request().Context(), &cartItem); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusCreated, constants.CartItemCreatedSuccess, cartItem)
}

func (h *CartItemHandler) GetByCartID(c echo.Context) error {
	cartID := c.Param("cart_id")
	cartItems, err := h.cartItemUseCase.GetByCartID(c.Request().Context(), cartID)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartItemRetrievedSuccess, cartItems)
}

func (h *CartItemHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	cartItem, err := h.cartItemUseCase.GetByID(c.Request().Context(), id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartItemRetrievedSuccess, cartItem)
}

func (h *CartItemHandler) GetAll(c echo.Context) error {
	cartItems, err := h.cartItemUseCase.GetAll(c.Request().Context())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartItemRetrievedSuccess, cartItems)
}

func (h *CartItemHandler) Update(c echo.Context) error {
	var cartItem domain.CartItem
	if err := c.Bind(&cartItem); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	if err := h.cartItemUseCase.Update(c.Request().Context(), &cartItem); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartItemUpdatedSuccess, cartItem)
}

func (h *CartItemHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.cartItemUseCase.Delete(c.Request().Context(), id); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CartItemDeletedSuccess, nil)
}

================
File: internal/delivery/http/handler/category_handler.go
================
package handler

import (
	"net/http"

	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type CategoryHandler struct {
	BaseHandler
	categoryUseCase domain.CategoryUseCase
}

func NewCategoryHandler(uc domain.CategoryUseCase) CategoryHandler {
	return CategoryHandler{
		BaseHandler:     BaseHandler{validator: validator.NewValidator()},
		categoryUseCase: uc,
	}
}
func (h *CategoryHandler) Create(c echo.Context) error {
	var category domain.Category
	if err := c.Bind(&category); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	if err := h.categoryUseCase.Create(c.Request().Context(), &category); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusCreated, constants.CategoryCreatedSuccess, category)
}

func (h *CategoryHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	category, err := h.categoryUseCase.GetByID(c.Request().Context(), id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CategoryRetrievedSuccess, category)
}

func (h *CategoryHandler) GetAll(c echo.Context) error {
	categories, err := h.categoryUseCase.GetAll(c.Request().Context())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CategoriesRetrievedSuccess, categories)
}

func (h *CategoryHandler) Update(c echo.Context) error {
	id := c.Param("id")
	var category domain.Category
	if err := c.Bind(&category); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.CategoryInvalidDataError)
	}

	category.ID = objectID
	if err := h.categoryUseCase.Update(c.Request().Context(), &category); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CategoryUpdatedSuccess, category)
}

func (h *CategoryHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.categoryUseCase.Delete(c.Request().Context(), id); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.CategoryDeletedSuccess, nil)
}

================
File: internal/delivery/http/handler/handler.go
================
package handler

import (
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"play-to-win-api/internal/delivery/http/middleware"

	"github.com/labstack/echo/v4"
)

type Handlers struct {
	Category CategoryHandler
	Auth     AuthHandler
	AuthMW   *middleware.AuthMiddleware
	Product  ProductHandler
	Campaign CampaignHandler
	Cart     CartHandler
	CartItem CartItemHandler
}

func NewHandlers(e *echo.Echo, categoryUseCase domain.CategoryUseCase, authUseCase domain.AuthUseCase, productUseCase domain.ProductUseCase, campaignUseCase domain.CampaignUseCase, cartUseCase domain.CartUseCase, cartItemUseCase domain.CartItemUseCase) *Handlers {
	validator := validator.NewValidator()
	return &Handlers{
		Category: NewCategoryHandler(categoryUseCase),
		Auth:     NewAuthHandler(authUseCase, validator),
		Product:  NewProductHandler(productUseCase),
		Campaign: NewCampaignHandler(campaignUseCase),
		Cart:     NewCartHandler(cartUseCase, authUseCase),
		CartItem: NewCartItemHandler(cartItemUseCase),
	}
}

type BaseHandler struct {
	validator *validator.CustomValidator
}

================
File: internal/delivery/http/handler/product_handler.go
================
package handler

import (
	"net/http"

	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/response"
	"play-to-win-api/internal/domain"
	"play-to-win-api/pkg/validator"

	"github.com/labstack/echo/v4"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type ProductHandler struct {
	BaseHandler
	productUseCase domain.ProductUseCase
}

func NewProductHandler(uc domain.ProductUseCase) ProductHandler {
	return ProductHandler{
		BaseHandler:    BaseHandler{validator: validator.NewValidator()},
		productUseCase: uc,
	}
}

func (h *ProductHandler) Create(c echo.Context) error {
	var product domain.Product
	if err := c.Bind(&product); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	if err := h.productUseCase.Create(c.Request().Context(), &product); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusCreated, constants.ProductCreatedSuccess, product)
}

func (h *ProductHandler) GetByID(c echo.Context) error {
	id := c.Param("id")
	product, err := h.productUseCase.GetByID(c.Request().Context(), id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.ProductRetrievedSuccess, product)
}

func (h *ProductHandler) GetAll(c echo.Context) error {
	products, err := h.productUseCase.GetAll(c.Request().Context())
	if err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.ProductsRetrievedSuccess, products)
}

func (h *ProductHandler) Update(c echo.Context) error {
	id := c.Param("id")
	var product domain.Product
	if err := c.Bind(&product); err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.InvalidRequestError)
	}

	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return response.ErrorResponse(c, http.StatusBadRequest, constants.CategoryInvalidDataError)
	}

	product.ID = objectID

	if err := h.productUseCase.Update(c.Request().Context(), &product); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.ProductUpdatedSuccess, product)
}

func (h *ProductHandler) Delete(c echo.Context) error {
	id := c.Param("id")
	if err := h.productUseCase.Delete(c.Request().Context(), id); err != nil {
		return response.ErrorResponse(c, http.StatusInternalServerError, err.Error())
	}

	return response.NewResponse(c, http.StatusOK, constants.ProductDeletedSuccess, nil)
}

================
File: internal/delivery/http/middleware/auth_middileware.go
================
package middleware

import (
	"fmt"
	"net/http"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/delivery/http/response"
	"strings"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

type AuthMiddleware struct {
	accessSecret string
}

func NewAuthMiddleware(accessSecret string) *AuthMiddleware {
	if accessSecret == "" {
		panic("access secret cannot be empty")
	}
	return &AuthMiddleware{
		accessSecret: accessSecret,
	}
}

type Claims struct {
	UserID string `json:"user_id"`
	Email  string `json:"email"`
	Role   string `json:"role"`
	jwt.RegisteredClaims
}

func (m *AuthMiddleware) Authenticate(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		authHeader := c.Request().Header.Get("Authorization")
		if authHeader == "" {
			return response.ErrorResponse(c, http.StatusUnauthorized, constants.MissingAuthHeader)
		}

		tokenParts := strings.Split(authHeader, " ")
		if len(tokenParts) != 2 || tokenParts[0] != "Bearer" {
			return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidAuthHeader)
		}

		token, err := jwt.ParseWithClaims(tokenParts[1], &Claims{}, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return []byte(m.accessSecret), nil
		})

		if err != nil {
			return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidToken+err.Error())
		}

		claims, ok := token.Claims.(*Claims)
		if !ok || !token.Valid {
			return response.ErrorResponse(c, http.StatusUnauthorized, constants.InvalidUserClaims)
		}
		c.Set("user", claims)
		return next(c)
	}
}

func RequireRole(roles ...string) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			user, ok := c.Get("user").(*Claims)
			if !ok {
				return response.ErrorResponse(c, http.StatusUnauthorized, constants.NotAuthenticated)
			}

			for _, role := range roles {
				if user.Role == role {
					return next(c)
				}
			}

			return response.ErrorResponse(c, http.StatusForbidden, constants.InsufficientPerms)
		}
	}
}

================
File: internal/delivery/http/middleware/middleware.go
================
package middleware

import (
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func SetupMiddleware(e *echo.Echo) {
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	e.Use(middleware.CORS())
	e.Use(middleware.RequestID())
	e.Use(CustomContextMiddleware)
}

func CustomContextMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		cc := &CustomContext{c}
		return next(cc)
	}
}

type CustomContext struct {
	echo.Context
}

================
File: internal/delivery/http/response/response.go
================
package response

import (
	"github.com/labstack/echo/v4"
)

type Response struct {
	Status  bool        `json:"status"`
	Message string      `json:"message"`
	Code    int         `json:"code"`
	Data    interface{} `json:"data"`
}

func NewResponse(c echo.Context, code int, message string, data interface{}) error {
	return c.JSON(code, Response{
		Status:  code >= 200 && code < 300,
		Message: message,
		Code:    code,
		Data:    data,
	})
}

func ErrorResponse(c echo.Context, code int, message string) error {
	return NewResponse(c, code, message, nil)
}

================
File: internal/delivery/http/routes/route.go
================
package route

import (
	"play-to-win-api/internal/delivery/http/handler"
	"play-to-win-api/internal/delivery/http/middleware"

	"github.com/labstack/echo/v4"
)

func SetupRoutes(e *echo.Echo, handlers *handler.Handlers) {
	middleware.SetupMiddleware(e)

	v1 := e.Group("/api/v1")

	categories := v1.Group("/categories")
	categories.GET("", handlers.Category.GetAll)
	categories.GET("/:id", handlers.Category.GetByID)

	protectedCategories := categories.Group("")
	protectedCategories.Use(handlers.AuthMW.Authenticate)

	adminCategories := protectedCategories.Group("")
	adminCategories.Use(middleware.RequireRole("admin"))
	adminCategories.POST("", handlers.Category.Create)
	adminCategories.PUT("/:id", handlers.Category.Update)
	adminCategories.DELETE("/:id", handlers.Category.Delete)

	auth := v1.Group("/auth")
	auth.POST("/register", handlers.Auth.Register)
	auth.POST("/login", handlers.Auth.Login)
	auth.POST("/refresh", handlers.Auth.RefreshToken)

	user := v1.Group("/user")
	user.Use(handlers.AuthMW.Authenticate)
	user.GET("/profile", handlers.Auth.GetProfile)

	products := v1.Group("/products")
	products.GET("", handlers.Product.GetAll)
	products.GET("/:id", handlers.Product.GetByID)

	protectedProducts := products.Group("")
	protectedProducts.Use(handlers.AuthMW.Authenticate)

	adminProducts := protectedProducts.Group("")
	adminProducts.Use(middleware.RequireRole("admin"))
	adminProducts.POST("", handlers.Product.Create)
	adminProducts.PUT("/:id", handlers.Product.Update)
	adminProducts.DELETE("/:id", handlers.Product.Delete)

	campaigns := v1.Group("/campaigns")
	campaigns.GET("", handlers.Campaign.GetAll)
	campaigns.GET("/:id", handlers.Campaign.GetByID)

	protectedCampaigns := campaigns.Group("")
	protectedCampaigns.Use(handlers.AuthMW.Authenticate)

	adminCampaigns := protectedCampaigns.Group("")
	adminCampaigns.Use(middleware.RequireRole("admin"))
	adminCampaigns.POST("", handlers.Campaign.Create)
	adminCampaigns.PUT("/:id", handlers.Campaign.Update)
	adminCampaigns.DELETE("/:id", handlers.Campaign.Delete)

	carts := v1.Group("/carts")

	protectedCart := carts.Group("")
	protectedCart.Use(handlers.AuthMW.Authenticate)

	protectedCart.GET("", handlers.Cart.GetByUserID)
	protectedCart.GET("/:id", handlers.Cart.GetByID)
	protectedCart.POST("", handlers.Cart.Create)
	protectedCart.PUT("/:id", handlers.Cart.Update)
	protectedCart.DELETE("/:id", handlers.Cart.Delete)

	cartItems := v1.Group("/cart-items")

	protectedCartItems := cartItems.Group("")
	protectedCartItems.Use(handlers.AuthMW.Authenticate)

	protectedCartItems.GET("/:cart_id", handlers.CartItem.GetByCartID)
	protectedCartItems.POST("", handlers.CartItem.Create)
	protectedCartItems.PUT("/:id", handlers.CartItem.Update)
	protectedCartItems.DELETE("/:id", handlers.CartItem.Delete)

	adminCartItems := protectedCartItems.Group("")
	adminCartItems.Use(middleware.RequireRole("admin"))
	adminCartItems.GET("", handlers.CartItem.GetAll)
}

================
File: internal/domain/campaigns.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Campaign struct {
	ID        primitive.ObjectID `bson:"_id,omitempty"`
	Name      string             `bson:"name" json:"name" validate:"required"`
	Category  string             `bson:"category" json:"category" validate:"required"`
	IsActive  bool               `bson:"is_active" json:"is_active" default:"true"`
	StartDate time.Time          `bson:"start_date" json:"start_date" default:"time.Now()"`
	EndDate   time.Time          `bson:"end_date" json:"end_date" default:"time.Now().AddDate(0, 0, 7)"`
	CreatedAt time.Time          `bson:"created_at" json:"created_at"`
	UpdatedAt time.Time          `bson:"updated_at" json:"updated_at"`
}

type CampaignRepository interface {
	Create(ctx context.Context, campaign *Campaign) error
	FindByID(ctx context.Context, id string) (*Campaign, error)
	FindAll(ctx context.Context) ([]Campaign, error)
	Update(ctx context.Context, campaign *Campaign) error
	Delete(ctx context.Context, id string) error
}

type CampaignUseCase interface {
	Create(ctx context.Context, campaign *Campaign) error
	GetByID(ctx context.Context, id string) (*Campaign, error)
	GetAll(ctx context.Context) ([]Campaign, error)
	Update(ctx context.Context, campaign *Campaign) error
	Delete(ctx context.Context, id string) error
}

================
File: internal/domain/cart.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Cart struct {
	ID          primitive.ObjectID `bson:"_id,omitempty"`
	User        User               `bson:"user" json:"user"`
	TotalAmount float64            `bson:"total_amount" json:"total_amount" validate:"required"`
	CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
	UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}

type CartRepository interface {
	Create(cart *Cart) error
	FindByUserID(ctx context.Context, userID string) ([]Cart, error)
	FindByID(ctx context.Context, id string) (*Cart, error)
	FindAll(ctx context.Context) ([]Cart, error)
	Update(ctx context.Context, cart *Cart) error
	Delete(ctx context.Context, id string) error
}

type CartUseCase interface {
	Create(ctx context.Context, cart *Cart) error
	GetByUserID(ctx context.Context, userID string) ([]Cart, error)
	GetByID(ctx context.Context, id string) (*Cart, error)
	GetAll(ctx context.Context) ([]Cart, error)
	Update(ctx context.Context, cart *Cart) error
	Delete(ctx context.Context, id string) error
}

================
File: internal/domain/cartItem.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type CartItem struct {
	ID         primitive.ObjectID `bson:"_id,omitempty"`
	CartId     primitive.ObjectID `bson:"cart_id,omitempty" json:"cart_id" validate:"required"`
	ProductId  primitive.ObjectID `bson:"product_id,omitempty" json:"product_id" validate:"required"`
	Quantity   int                `bson:"quantity,omitempty" json:"quantity" validate:"required"`
	Category   string             `bson:"category,omitempty" json:"category" validate:"required"`
	UnitPrice  float64            `bson:"unit_price,omitempty" json:"unit_price" validate:"required"`
	TotalPrice float64            `bson:"total_price,omitempty" json:"total_price" validate:"required"`
	CreatedAt  time.Time          `bson:"created_at,omitempty" json:"created_at"`
	UpdatedAt  time.Time          `bson:"updated_at,omitempty" json:"updated_at"`
}

type CartItemRepository interface {
	Create(ctx context.Context, cartItem *CartItem) error
	FindByCartID(ctx context.Context, cartID string) ([]CartItem, error)
	FindByID(ctx context.Context, id string) (*CartItem, error)
	FindAll(ctx context.Context) ([]CartItem, error)
	Update(ctx context.Context, cartItem *CartItem) error
	Delete(ctx context.Context, id string) error
}

type CartItemUseCase interface {
	Create(ctx context.Context, cartItem *CartItem) error
	GetByCartID(ctx context.Context, cartID string) ([]CartItem, error)
	GetByID(ctx context.Context, id string) (*CartItem, error)
	GetAll(ctx context.Context) ([]CartItem, error)
	Update(ctx context.Context, cartItem *CartItem) error
	Delete(ctx context.Context, id string) error
}

================
File: internal/domain/category.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Category struct {
	ID          primitive.ObjectID `bson:"_id,omitempty"`
	Name        string             `bson:"name" json:"name" validate:"required"`
	Description string             `bson:"description" json:"description" validate:"required"`
	CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
	UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}

type CategoryRepository interface {
	Create(ctx context.Context, category *Category) error
	FindByID(ctx context.Context, id string) (*Category, error)
	FindAll(ctx context.Context) ([]Category, error)
	Update(ctx context.Context, category *Category) error
	Delete(ctx context.Context, id string) error
}

type CategoryUseCase interface {
	Create(ctx context.Context, category *Category) error
	GetByID(ctx context.Context, id string) (*Category, error)
	GetAll(ctx context.Context) ([]Category, error)
	Update(ctx context.Context, category *Category) error
	Delete(ctx context.Context, id string) error
}

================
File: internal/domain/error.go
================
package domain

import "errors"

var (
	ErrInternalServerError = errors.New("internal server error")
	ErrNotFound            = errors.New("requested resource not found")
	ErrConflict            = errors.New("resource already exists")
	ErrBadRequest          = errors.New("invalid request")
	ErrUnauthorized        = errors.New("unauthorized access")

	ErrCategoryNotFound      = errors.New("category not found")
	ErrCategoryAlreadyExists = errors.New("category already exists")
	ErrInvalidCategoryID     = errors.New("invalid category ID")

	ErrUserNotFound      = errors.New("user not found")
	ErrUserAlreadyExists = errors.New("user already exists")
	ErrInvalidUserID     = errors.New("invalid user ID")
	ErrInvalidUserData   = errors.New("invalid user data")

	ErrInvalidToken       = errors.New("invalid token")
	ErrInvalidCredentials = errors.New("invalid credentials")

	ErrProductNotFound      = errors.New("product not found")
	ErrProductAlreadyExists = errors.New("product already exists")
	ErrInvalidProductID     = errors.New("invalid product ID")
	ErrInvalidProductData   = errors.New("invalid product data")

	ErrCampaignNotFound      = errors.New("campaign not found")
	ErrCampaignAlreadyExists = errors.New("campaign already exists")
	ErrInvalidCampaignID     = errors.New("invalid campaign ID")
	ErrInvalidCampaignData   = errors.New("invalid campaign data")

	ErrCartNotFound  = errors.New("cart not found")
	ErrInvalidCartID = errors.New("invalid cart ID")

	ErrCartItemNotFound  = errors.New("cart item not found")
	ErrInvalidCartItemID = errors.New("invalid cart item ID")
)

================
File: internal/domain/product.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Product struct {
	ID          primitive.ObjectID `bson:"_id,omitempty"`
	Name        string             `bson:"name" json:"name" validate:"required"`
	Description string             `bson:"description" json:"description" validate:"required"`
	Content     string             `bson:"content" json:"content" validate:"required"`
	Price       float64            `bson:"price" json:"price" validate:"required"`
	Image       string             `bson:"image" json:"image" validate:"required"`
	Sold        int                `bson:"sold" json:"sold"`
	Stock       int                `bson:"stock" json:"stock"`
	CreatedAt   time.Time          `bson:"created_at" json:"created_at"`
	UpdatedAt   time.Time          `bson:"updated_at" json:"updated_at"`
}

type ProductRepository interface {
	Create(ctx context.Context, product *Product) error
	FindByID(ctx context.Context, id string) (*Product, error)
	FindAll(ctx context.Context) ([]Product, error)
	Update(ctx context.Context, product *Product) error
	Delete(ctx context.Context, id string) error
}

type ProductUseCase interface {
	Create(ctx context.Context, product *Product) error
	GetByID(ctx context.Context, id string) (*Product, error)
	GetAll(ctx context.Context) ([]Product, error)
	Update(ctx context.Context, product *Product) error
	Delete(ctx context.Context, id string) error
}

================
File: internal/domain/user.go
================
package domain

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type User struct {
	ID           primitive.ObjectID `bson:"_id,omitempty" json:"id,omitempty"`
	Name         string             `bson:"name" json:"name" validate:"required"`
	Email        string             `bson:"email" json:"email" validate:"required,email"`
	Password     string             `bson:"password" json:"password,omitempty" validate:"required,min=6"`
	Role         string             `bson:"role" json:"role"`
	RefreshToken string             `bson:"refresh_token,omitempty" json:"-"`
	CreatedAt    time.Time          `bson:"created_at" json:"created_at"`
	UpdatedAt    time.Time          `bson:"updated_at" json:"updated_at"`
}

type UserProfile struct {
	ID        primitive.ObjectID `json:"id"`
	Email     string             `json:"email"`
	Name      string             `json:"name"`
	Role      string             `json:"role"`
	CreatedAt time.Time          `json:"created_at"`
}

type TokenPair struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

type UserRepository interface {
	Create(ctx context.Context, user *User) error
	FindByEmail(ctx context.Context, email string) (*User, error)
	UpdateRefreshToken(ctx context.Context, userID primitive.ObjectID, token string) error
	FindByID(ctx context.Context, id primitive.ObjectID) (*User, error)
}

type AuthUseCase interface {
	Register(ctx context.Context, user *User) (*TokenPair, error)
	Login(ctx context.Context, email, password string) (*TokenPair, error)
	RefreshToken(ctx context.Context, refreshToken string) (*TokenPair, error)
	GetProfile(ctx context.Context, id string) (*UserProfile, error)
	GetUserByEmail(ctx context.Context, email string) (*User, error)
}

type Claims struct {
	ID string `json:"id"`

	Email string `json:"email"`
}

================
File: internal/repository/mongodb/campaign_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type campaignRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewCampaignRepository(db *mongo.Database) domain.CampaignRepository {
	return &campaignRepository{
		db:   db,
		coll: db.Collection("campaigns"),
	}
}

func (r *campaignRepository) Create(ctx context.Context, c *domain.Campaign) error {
	c.CreatedAt = time.Now()
	c.UpdatedAt = time.Now()
	result, err := r.coll.InsertOne(ctx, c)
	if err != nil {
		return err
	}
	c.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *campaignRepository) FindByID(ctx context.Context, id string) (*domain.Campaign, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var campaign domain.Campaign
	err = r.coll.FindOne(ctx, primitive.M{"_id": objectID}).Decode(&campaign)
	return &campaign, err
}

func (r *campaignRepository) FindAll(ctx context.Context) ([]domain.Campaign, error) {
	cursor, err := r.coll.Find(ctx, primitive.M{})
	if err != nil {
		return nil, err
	}
	var campaigns []domain.Campaign
	err = cursor.All(ctx, &campaigns)
	return campaigns, err
}

func (r *campaignRepository) Update(ctx context.Context, c *domain.Campaign) error {
	c.UpdatedAt = time.Now()
	_, err := r.coll.UpdateOne(
		ctx,
		primitive.M{"_id": c.ID},
		primitive.M{"$set": c},
	)
	return err
}

func (r *campaignRepository) Delete(ctx context.Context, id string) error {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	_, err = r.coll.DeleteOne(ctx, primitive.M{"_id": objectID})
	return err
}

================
File: internal/repository/mongodb/cart_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type cartRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewCartRepository(db *mongo.Database) domain.CartRepository {
	return &cartRepository{
		db:   db,
		coll: db.Collection("carts"),
	}
}

func (r *cartRepository) Create(cart *domain.Cart) error {
	cart.CreatedAt = time.Now()
	cart.UpdatedAt = time.Now()
	result, err := r.coll.InsertOne(context.Background(), cart)
	if err != nil {
		return err
	}
	cart.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *cartRepository) FindByUserID(ctx context.Context, userID string) ([]domain.Cart, error) {
	objectID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, domain.ErrInvalidCartID
	}

	pipeline := []bson.M{
		{
			"$match": bson.M{
				"user._id": objectID,
			},
		},
		{
			"$lookup": bson.M{
				"from":         "users",
				"localField":   "user._id",
				"foreignField": "_id",
				"as":           "user_data",
			},
		},
		{
			"$unwind": "$user_data",
		},
		{
			"$addFields": bson.M{
				"user": "$user_data",
			},
		},
		{
			"$project": bson.M{
				"user_data": 0,
			},
		},
	}

	cursor, err := r.coll.Aggregate(ctx, pipeline)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var carts []domain.Cart
	if err := cursor.All(ctx, &carts); err != nil {
		return nil, err
	}

	return carts, nil
}

func (r *cartRepository) FindByID(ctx context.Context, id string) (*domain.Cart, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var cart domain.Cart
	err = r.coll.FindOne(ctx, primitive.M{"_id": objectID}).Decode(&cart)
	return &cart, err
}

func (r *cartRepository) FindAll(ctx context.Context) ([]domain.Cart, error) {
	cursor, err := r.coll.Find(ctx, primitive.M{})
	if err != nil {
		return nil, err
	}
	var carts []domain.Cart
	err = cursor.All(ctx, &carts)
	return carts, err
}

func (r *cartRepository) Update(ctx context.Context, cart *domain.Cart) error {
	cart.UpdatedAt = time.Now()
	_, err := r.coll.UpdateOne(
		ctx,
		primitive.M{"_id": cart.ID},
		primitive.M{"$set": cart},
	)
	return err
}

func (r *cartRepository) Delete(ctx context.Context, id string) error {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	_, err = r.coll.DeleteOne(ctx, primitive.M{"_id": objectID})
	return err
}

================
File: internal/repository/mongodb/cartItem_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type cartItemRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewCartItemRepository(db *mongo.Database) domain.CartItemRepository {
	return &cartItemRepository{
		db:   db,
		coll: db.Collection("cart_items"),
	}
}

func (r *cartItemRepository) Create(ctx context.Context, cartItem *domain.CartItem) error {
	cartItem.CreatedAt = time.Now()
	cartItem.UpdatedAt = time.Now()
	result, err := r.coll.InsertOne(ctx, cartItem)
	if err != nil {
		return err
	}
	cartItem.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *cartItemRepository) FindByCartID(ctx context.Context, cartID string) ([]domain.CartItem, error) {
	objectID, err := primitive.ObjectIDFromHex(cartID)
	if err != nil {
		return nil, domain.ErrInvalidCartItemID
	}

	cursor, err := r.coll.Find(ctx, bson.M{"cart_id": objectID})
	if err != nil {
		return nil, err
	}

	var cartItems []domain.CartItem
	if err = cursor.All(ctx, &cartItems); err != nil {
		return nil, err
	}

	return cartItems, nil
}

func (r *cartItemRepository) FindByID(ctx context.Context, id string) (*domain.CartItem, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, domain.ErrInvalidCartItemID
	}

	var cartItem domain.CartItem
	if err := r.coll.FindOne(ctx, bson.M{"_id": objectID}).Decode(&cartItem); err != nil {
		return nil, err
	}

	return &cartItem, nil
}

func (r *cartItemRepository) FindAll(ctx context.Context) ([]domain.CartItem, error) {
	cursor, err := r.coll.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}

	var cartItems []domain.CartItem
	if err = cursor.All(ctx, &cartItems); err != nil {
		return nil, err
	}

	return cartItems, nil
}

func (r *cartItemRepository) Update(ctx context.Context, cartItem *domain.CartItem) error {
	cartItem.UpdatedAt = time.Now()
	_, err := r.coll.UpdateOne(
		ctx,
		bson.M{"_id": cartItem.ID},
		bson.M{"$set": cartItem},
	)
	return err
}

func (r *cartItemRepository) Delete(ctx context.Context, id string) error {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return domain.ErrInvalidCartItemID
	}

	_, err = r.coll.DeleteOne(ctx, bson.M{"_id": objectID})
	return err
}

================
File: internal/repository/mongodb/category_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type categoryRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewCategoryRepository(db *mongo.Database) domain.CategoryRepository {
	return &categoryRepository{
		db:   db,
		coll: db.Collection("categories"),
	}
}

func (r *categoryRepository) Create(ctx context.Context, c *domain.Category) error {
	c.CreatedAt = time.Now()
	c.UpdatedAt = time.Now()
	result, err := r.coll.InsertOne(ctx, c)
	if err != nil {
		return err
	}
	c.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *categoryRepository) FindByID(ctx context.Context, id string) (*domain.Category, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var category domain.Category
	err = r.coll.FindOne(ctx, primitive.M{"_id": objectID}).Decode(&category)
	return &category, err
}

func (r *categoryRepository) FindAll(ctx context.Context) ([]domain.Category, error) {
	cursor, err := r.coll.Find(ctx, primitive.M{})
	if err != nil {
		return nil, err
	}
	var categories []domain.Category
	err = cursor.All(ctx, &categories)
	return categories, err
}

func (r *categoryRepository) Update(ctx context.Context, c *domain.Category) error {
	c.UpdatedAt = time.Now()
	_, err := r.coll.UpdateOne(
		ctx,
		primitive.M{"_id": c.ID},
		primitive.M{"$set": c},
	)
	return err
}

func (r *categoryRepository) Delete(ctx context.Context, id string) error {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	_, err = r.coll.DeleteOne(ctx, primitive.M{"_id": objectID})
	return err
}

================
File: internal/repository/mongodb/product_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type productRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewProductRepository(db *mongo.Database) domain.ProductRepository {
	return &productRepository{
		db:   db,
		coll: db.Collection("products"),
	}
}

func (r *productRepository) Create(ctx context.Context, p *domain.Product) error {
	p.CreatedAt = time.Now()
	p.UpdatedAt = time.Now()
	result, err := r.coll.InsertOne(ctx, p)
	if err != nil {
		return err
	}
	p.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *productRepository) FindByID(ctx context.Context, id string) (*domain.Product, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var product domain.Product
	err = r.coll.FindOne(ctx, primitive.M{"_id": objectID}).Decode(&product)
	return &product, err
}

func (r *productRepository) FindAll(ctx context.Context) ([]domain.Product, error) {
	cursor, err := r.coll.Find(ctx, primitive.M{})
	if err != nil {
		return nil, err
	}
	var products []domain.Product
	err = cursor.All(ctx, &products)
	return products, err
}

func (r *productRepository) Update(ctx context.Context, p *domain.Product) error {
	p.UpdatedAt = time.Now()
	_, err := r.coll.UpdateOne(
		ctx,
		primitive.M{"_id": p.ID},
		primitive.M{"$set": p},
	)
	return err
}

func (r *productRepository) Delete(ctx context.Context, id string) error {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return err
	}
	_, err = r.coll.DeleteOne(ctx, primitive.M{"_id": objectID})
	return err
}

================
File: internal/repository/mongodb/user_repository.go
================
package mongodb

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type userRepository struct {
	db   *mongo.Database
	coll *mongo.Collection
}

func NewUserRepository(db *mongo.Database) domain.UserRepository {
	return &userRepository{
		db:   db,
		coll: db.Collection("users"),
	}
}

func (r *userRepository) Create(ctx context.Context, user *domain.User) error {
	user.CreatedAt = time.Now()
	user.UpdatedAt = time.Now()

	result, err := r.coll.InsertOne(ctx, user)
	if err != nil {
		return err
	}

	user.ID = result.InsertedID.(primitive.ObjectID)
	return nil
}

func (r *userRepository) FindByID(ctx context.Context, id primitive.ObjectID) (*domain.User, error) {
	var user domain.User
	err := r.coll.FindOne(ctx, bson.M{"_id": id}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, domain.ErrUserNotFound
	}
	return &user, err
}

func (r *userRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	var user domain.User
	err := r.coll.FindOne(ctx, bson.M{"email": email}).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, domain.ErrUserNotFound
	}
	return &user, err
}

func (r *userRepository) UpdateRefreshToken(ctx context.Context, userID primitive.ObjectID, token string) error {
	_, err := r.coll.UpdateOne(
		ctx,
		bson.M{"_id": userID},
		bson.M{"$set": bson.M{
			"refresh_token": token,
			"updated_at":    time.Now(),
		}},
	)
	return err
}

================
File: internal/repository/repository.go
================
package repository

import (
	"context"
	"play-to-win-api/internal/domain"
)

type Repositories struct {
	Category domain.CategoryRepository
}

type Transaction interface {
	WithinTransaction(ctx context.Context, fn func(ctx context.Context) error) error
}

func NewRepositories(categoryRepo domain.CategoryRepository) *Repositories {
	return &Repositories{
		Category: categoryRepo,
	}
}

================
File: internal/usecase/auth_usecase.go
================
package usecase

import (
	"context"
	"play-to-win-api/internal/domain"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
)

type authUseCase struct {
	userRepo      domain.UserRepository
	accessSecret  string
	refreshSecret string
	accessTTL     time.Duration
	refreshTTL    time.Duration
}

func NewAuthUseCase(
	ur domain.UserRepository,
	accessSecret, refreshSecret string,
	accessTTL, refreshTTL time.Duration,
) domain.AuthUseCase {
	return &authUseCase{
		userRepo:      ur,
		accessSecret:  accessSecret,
		refreshSecret: refreshSecret,
		accessTTL:     accessTTL,
		refreshTTL:    refreshTTL,
	}
}

type Claims struct {
	Email string `json:"email"`
	Role  string `json:"role"`
	jwt.RegisteredClaims
}

func (uc *authUseCase) Register(ctx context.Context, user *domain.User) (*domain.TokenPair, error) {
	existingUser, _ := uc.userRepo.FindByEmail(ctx, user.Email)
	if existingUser != nil {
		return nil, domain.ErrUserAlreadyExists
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	user.Password = string(hashedPassword)
	user.Role = "user"
	user.CreatedAt = time.Now()
	user.UpdatedAt = time.Now()

	if err := uc.userRepo.Create(ctx, user); err != nil {
		return nil, err
	}

	accessToken, err := uc.generateToken(user, uc.accessSecret, uc.accessTTL)
	if err != nil {
		return nil, err
	}

	refreshToken, err := uc.generateToken(user, uc.refreshSecret, uc.refreshTTL)
	if err != nil {
		return nil, err
	}

	if err := uc.userRepo.UpdateRefreshToken(ctx, user.ID, refreshToken); err != nil {
		return nil, err
	}

	return &domain.TokenPair{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}
func (uc *authUseCase) Login(ctx context.Context, email, password string) (*domain.TokenPair, error) {
	user, err := uc.userRepo.FindByEmail(ctx, email)
	if err != nil {
		return nil, domain.ErrInvalidCredentials
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return nil, domain.ErrInvalidCredentials
	}

	return uc.generateTokenPair(user)
}

func (uc *authUseCase) RefreshToken(ctx context.Context, refreshToken string) (*domain.TokenPair, error) {
	claims := &Claims{}
	token, err := jwt.ParseWithClaims(refreshToken, claims, func(t *jwt.Token) (interface{}, error) {
		return []byte(uc.refreshSecret), nil
	})

	if err != nil || !token.Valid {
		return nil, domain.ErrInvalidToken
	}

	user, err := uc.userRepo.FindByEmail(ctx, claims.Email)
	if err != nil {
		return nil, err
	}

	if user.RefreshToken != refreshToken {
		return nil, domain.ErrInvalidToken
	}

	return uc.generateTokenPair(user)
}

func (uc *authUseCase) generateTokenPair(user *domain.User) (*domain.TokenPair, error) {
	accessToken, err := uc.generateToken(user, uc.accessSecret, uc.accessTTL)
	if err != nil {
		return nil, err
	}

	refreshToken, err := uc.generateToken(user, uc.refreshSecret, uc.refreshTTL)
	if err != nil {
		return nil, err
	}

	err = uc.userRepo.UpdateRefreshToken(context.Background(), user.ID, refreshToken)
	if err != nil {
		return nil, err
	}

	return &domain.TokenPair{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

func (uc *authUseCase) generateToken(user *domain.User, secret string, expiry time.Duration) (string, error) {
	claims := Claims{
		Email: user.Email,
		Role:  user.Role,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			NotBefore: jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secret))
}

func (uc *authUseCase) GetUserByEmail(ctx context.Context, email string) (*domain.User, error) {
	return uc.userRepo.FindByEmail(ctx, email)
}

func (uc *authUseCase) GetProfile(ctx context.Context, userID string) (*domain.UserProfile, error) {
	objectID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, err
	}

	user, err := uc.userRepo.FindByID(ctx, objectID)
	if err != nil {
		return nil, err
	}

	return &domain.UserProfile{
		ID:        user.ID,
		Name:      user.Name,
		Email:     user.Email,
		Role:      user.Role,
		CreatedAt: user.CreatedAt,
	}, nil
}

================
File: internal/usecase/campaign_usecase.go
================
package usecase

import (
	"context"
	"errors"
	"fmt"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/domain"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type compaginUseCase struct {
	campaignRepo domain.CampaignRepository
}

func NewCampaignUseCase(cr domain.CampaignRepository) domain.CampaignUseCase {
	return &compaginUseCase{
		campaignRepo: cr,
	}
}

func (uc *compaginUseCase) Create(ctx context.Context, campaign *domain.Campaign) error {
	return uc.campaignRepo.Create(ctx, campaign)
}

func (uc *compaginUseCase) GetByID(ctx context.Context, id string) (*domain.Campaign, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, domain.ErrInvalidCampaignID
	}

	campaign, err := uc.campaignRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, domain.ErrCampaignNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CampaignNotFoundError))
	}
	return campaign, nil
}

func (uc *compaginUseCase) GetAll(ctx context.Context) ([]domain.Campaign, error) {
	return uc.campaignRepo.FindAll(ctx)
}

func (uc *compaginUseCase) Update(ctx context.Context, campaign *domain.Campaign) error {
	return uc.campaignRepo.Update(ctx, campaign)
}

func (uc *compaginUseCase) Delete(ctx context.Context, id string) error {
	if !primitive.IsValidObjectID(id) {
		return domain.ErrInvalidCampaignID
	}

	return uc.campaignRepo.Delete(ctx, id)
}

================
File: internal/usecase/cart_usecase.go
================
package usecase

import (
	"context"
	"errors"
	"fmt"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/domain"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type cartUseCase struct {
	cartRepo domain.CartRepository
}

func NewCartUseCase(cr domain.CartRepository) domain.CartUseCase {
	return &cartUseCase{
		cartRepo: cr,
	}
}

func (uc *cartUseCase) Create(ctx context.Context, cart *domain.Cart) error {
	return uc.cartRepo.Create(cart)
}

func (uc *cartUseCase) GetByUserID(ctx context.Context, userID string) ([]domain.Cart, error) {
	if !primitive.IsValidObjectID(userID) {
		return nil, domain.ErrInvalidUserID
	}

	cart, err := uc.cartRepo.FindByUserID(ctx, userID)
	if err != nil {
		if errors.Is(err, domain.ErrCartNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CartNotFound))
	}
	return cart, nil
}

func (uc *cartUseCase) GetByID(ctx context.Context, id string) (*domain.Cart, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, domain.ErrInvalidCartID
	}

	cart, err := uc.cartRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, domain.ErrCartNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CartNotFound))
	}
	return cart, nil
}

func (uc *cartUseCase) GetAll(ctx context.Context) ([]domain.Cart, error) {
	return uc.cartRepo.FindAll(ctx)
}

func (uc *cartUseCase) Update(ctx context.Context, cart *domain.Cart) error {
	return uc.cartRepo.Update(ctx, cart)
}

func (uc *cartUseCase) Delete(ctx context.Context, id string) error {
	if !primitive.IsValidObjectID(id) {
		return domain.ErrInvalidCartID
	}

	return uc.cartRepo.Delete(ctx, id)
}

================
File: internal/usecase/cartItem_usecase.go
================
package usecase

import (
	"context"
	"errors"
	"fmt"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/domain"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type cartItemUseCase struct {
	cartItemRepo domain.CartItemRepository
}

func NewCartItemUseCase(cr domain.CartItemRepository) domain.CartItemUseCase {
	return &cartItemUseCase{
		cartItemRepo: cr,
	}
}

func (uc *cartItemUseCase) Create(ctx context.Context, cartItem *domain.CartItem) error {
	return uc.cartItemRepo.Create(ctx, cartItem)
}

func (uc *cartItemUseCase) GetByCartID(ctx context.Context, cartID string) ([]domain.CartItem, error) {
	if !primitive.IsValidObjectID(cartID) {
		return nil, domain.ErrInvalidCartID
	}

	cartItem, err := uc.cartItemRepo.FindByCartID(ctx, cartID)
	if err != nil {
		if errors.Is(err, domain.ErrCartItemNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CartItemNotFound))
	}
	return cartItem, nil
}

func (uc *cartItemUseCase) GetByID(ctx context.Context, id string) (*domain.CartItem, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, domain.ErrInvalidCartItemID
	}

	cartItem, err := uc.cartItemRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, domain.ErrCartItemNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CartItemNotFound))
	}
	return cartItem, nil
}

func (uc *cartItemUseCase) GetAll(ctx context.Context) ([]domain.CartItem, error) {
	return uc.cartItemRepo.FindAll(ctx)
}

func (uc *cartItemUseCase) Update(ctx context.Context, cartItem *domain.CartItem) error {
	return uc.cartItemRepo.Update(ctx, cartItem)
}

func (uc *cartItemUseCase) Delete(ctx context.Context, id string) error {
	return uc.cartItemRepo.Delete(ctx, id)
}

================
File: internal/usecase/category_usecase_test.go
================
package usecase

import (
	"context"
	"play-to-win-api/internal/domain"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type MockCategoryRepository struct {
	mock.Mock
}

func (m *MockCategoryRepository) Create(ctx context.Context, category *domain.Category) error {
	args := m.Called(ctx, category)
	return args.Error(0)
}

func (m *MockCategoryRepository) FindByID(ctx context.Context, id string) (*domain.Category, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(*domain.Category), args.Error(1)
}

func (m *MockCategoryRepository) FindAll(ctx context.Context) ([]domain.Category, error) {
	args := m.Called(ctx)
	return args.Get(0).([]domain.Category), args.Error(1)
}

func (m *MockCategoryRepository) Update(ctx context.Context, category *domain.Category) error {
	args := m.Called(ctx, category)
	return args.Error(0)
}

func (m *MockCategoryRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func TestCategoryUseCase_Create(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	category := &domain.Category{ID: primitive.NewObjectID(), Name: "Test Category"}
	mockRepo.On("Create", mock.Anything, category).Return(nil)

	err := uc.Create(context.Background(), category)
	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_GetByID_ValidID(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	categoryID := primitive.NewObjectID().Hex()
	objectID, _ := primitive.ObjectIDFromHex(categoryID)
	expectedCategory := &domain.Category{ID: objectID, Name: "Test Category"}
	mockRepo.On("FindByID", mock.Anything, categoryID).Return(expectedCategory, nil)

	category, err := uc.GetByID(context.Background(), categoryID)
	assert.NoError(t, err)
	assert.Equal(t, expectedCategory, category)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_GetByID_InvalidID(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	invalidID := "invalid-id"
	category, err := uc.GetByID(context.Background(), invalidID)
	assert.Nil(t, category)
	assert.ErrorIs(t, err, domain.ErrInvalidCategoryID)
}

func TestCategoryUseCase_GetByID_NotFound(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	categoryID := primitive.NewObjectID().Hex()
	mockRepo.On("FindByID", mock.Anything, categoryID).Return((*domain.Category)(nil), domain.ErrCategoryNotFound)

	category, err := uc.GetByID(context.Background(), categoryID)
	assert.Nil(t, category)
	assert.ErrorIs(t, err, domain.ErrCategoryNotFound)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_GetAll(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	expectedCategories := []domain.Category{
		{ID: primitive.NewObjectID(), Name: "Category 1"},
		{ID: primitive.NewObjectID(), Name: "Category 2"},
	}
	mockRepo.On("FindAll", mock.Anything).Return(expectedCategories, nil)

	categories, err := uc.GetAll(context.Background())
	assert.NoError(t, err)
	assert.Equal(t, expectedCategories, categories)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_Update(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	category := &domain.Category{ID: primitive.NewObjectID(), Name: "Updated Category"}
	mockRepo.On("Update", mock.Anything, category).Return(nil)

	err := uc.Update(context.Background(), category)
	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_Delete_ValidID(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	categoryID := primitive.NewObjectID().Hex()
	mockRepo.On("Delete", mock.Anything, categoryID).Return(nil)

	err := uc.Delete(context.Background(), categoryID)
	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

func TestCategoryUseCase_Delete_InvalidID(t *testing.T) {
	mockRepo := new(MockCategoryRepository)
	uc := NewCategoryUseCase(mockRepo)

	invalidID := "invalid-id"
	err := uc.Delete(context.Background(), invalidID)
	assert.ErrorIs(t, err, domain.ErrInvalidCategoryID)
}

================
File: internal/usecase/category_usecase.go
================
package usecase

import (
	"context"
	"errors"
	"fmt"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/domain"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type categoryUseCase struct {
	categoryRepo domain.CategoryRepository
}

func NewCategoryUseCase(cr domain.CategoryRepository) domain.CategoryUseCase {
	return &categoryUseCase{
		categoryRepo: cr,
	}
}

func (uc *categoryUseCase) Create(ctx context.Context, category *domain.Category) error {
	return uc.categoryRepo.Create(ctx, category)
}

func (uc *categoryUseCase) GetByID(ctx context.Context, id string) (*domain.Category, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, domain.ErrInvalidCategoryID
	}

	category, err := uc.categoryRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, domain.ErrCategoryNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.CategoryNotFoundError))
	}
	return category, nil
}

func (uc *categoryUseCase) GetAll(ctx context.Context) ([]domain.Category, error) {
	return uc.categoryRepo.FindAll(ctx)
}

func (uc *categoryUseCase) Update(ctx context.Context, category *domain.Category) error {
	return uc.categoryRepo.Update(ctx, category)
}

func (uc *categoryUseCase) Delete(ctx context.Context, id string) error {
	if !primitive.IsValidObjectID(id) {
		return domain.ErrInvalidCategoryID
	}

	return uc.categoryRepo.Delete(ctx, id)
}

================
File: internal/usecase/product_usecase.go
================
package usecase

import (
	"context"
	"errors"
	"fmt"
	"play-to-win-api/internal/constants"
	"play-to-win-api/internal/domain"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type productUseCase struct {
	productRepo domain.ProductRepository
}

func NewProductUseCase(pr domain.ProductRepository) domain.ProductUseCase {
	return &productUseCase{
		productRepo: pr,
	}
}

func (uc *productUseCase) Create(ctx context.Context, product *domain.Product) error {
	return uc.productRepo.Create(ctx, product)
}

func (uc *productUseCase) GetByID(ctx context.Context, id string) (*domain.Product, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, domain.ErrInvalidProductID
	}

	product, err := uc.productRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, domain.ErrProductNotFound) {
			return nil, err
		}
		return nil, fmt.Errorf(strings.ToLower(constants.ProductNotFoundError))
	}
	return product, nil
}

func (uc *productUseCase) GetAll(ctx context.Context) ([]domain.Product, error) {
	return uc.productRepo.FindAll(ctx)
}

func (uc *productUseCase) Update(ctx context.Context, product *domain.Product) error {
	return uc.productRepo.Update(ctx, product)
}

func (uc *productUseCase) Delete(ctx context.Context, id string) error {
	if !primitive.IsValidObjectID(id) {
		return domain.ErrInvalidProductID
	}

	return uc.productRepo.Delete(ctx, id)
}

================
File: pkg/mongodb/mongodb.go
================
package mongodb

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func NewClient(ctx context.Context, uri, dbName string) (*mongo.Database, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
	if err != nil {
		return nil, err
	}

	err = client.Ping(ctx, nil)
	if err != nil {
		return nil, err
	}

	return client.Database(dbName), nil
}

================
File: pkg/validator/validator.go
================
package validator

import (
	"regexp"

	"github.com/go-playground/validator/v10"
)

type CustomValidator struct {
	validator *validator.Validate
}

func NewValidator() *CustomValidator {
	v := validator.New()

	v.RegisterValidation("alpha_space", validateAlphaSpace)
	v.RegisterValidation("mongodb_objectid", validateMongoDBObjectID)

	return &CustomValidator{
		validator: v,
	}
}

func (cv *CustomValidator) Validate(i interface{}) error {
	return cv.validator.Struct(i)
}

func validateAlphaSpace(fl validator.FieldLevel) bool {
	matched, _ := regexp.Match(`^[a-zA-Z\s]*$`, []byte(fl.Field().String()))
	return matched
}

func validateMongoDBObjectID(fl validator.FieldLevel) bool {
	matched, _ := regexp.Match(`^[0-9a-fA-F]{24}$`, []byte(fl.Field().String()))
	return matched
}

func (cv *CustomValidator) RegisterValidation(tag string, fn validator.Func) error {
	return cv.validator.RegisterValidation(tag, fn)
}

================
File: .gitignore
================
.env

================
File: go.mod
================
module play-to-win-api

go 1.20

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	go.mongodb.org/mongo-driver/v2 v2.0.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

require (
	github.com/fatih/color v1.18.0
	github.com/go-playground/validator/v10 v10.23.0
	github.com/golang-jwt/jwt/v5 v5.2.1
	github.com/golang/snappy v0.0.4 // indirect
	github.com/joho/godotenv v1.5.1
	github.com/klauspost/compress v1.16.7 // indirect
	github.com/labstack/echo/v4 v4.13.0 // direct
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/montanaflynn/stats v0.7.1 // indirect
	github.com/stretchr/testify v1.10.0
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/xdg-go/pbkdf2 v1.0.0 // indirect
	github.com/xdg-go/scram v1.1.2 // indirect
	github.com/xdg-go/stringprep v1.0.4 // indirect
	github.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78 // indirect
	go.mongodb.org/mongo-driver v1.17.1
	golang.org/x/crypto v0.29.0 // indirect
	golang.org/x/net v0.24.0 // indirect
	golang.org/x/sync v0.9.0 // indirect
	golang.org/x/sys v0.27.0 // indirect
	golang.org/x/text v0.20.0 // indirect
)

================
File: go.sum
================
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=
github.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.23.0 h1:/PwmTwZhS0dPkav3cdK9kV1FsAmrL8sThn8IHr/sO+o=
github.com/go-playground/validator/v10 v10.23.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=
github.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/klauspost/compress v1.13.6 h1:P76CopJELS0TiO2mebmnzgWaajssP/EszplttgQxcgc=
github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
github.com/klauspost/compress v1.16.7 h1:2mk3MPGNzKyxErAw8YaohYh69+pa4sIQSC0fPGCFR9I=
github.com/klauspost/compress v1.16.7/go.mod h1:ntbaceVETuRiXiv4DpjP66DpAtAGkEQskQzEyD//IeE=
github.com/labstack/echo/v4 v4.13.0 h1:8DjSi4H/k+RqoOmwXkxW14A2H1pdPdS95+qmdJ4q1Tg=
github.com/labstack/echo/v4 v4.13.0/go.mod h1:61j7WN2+bp8V21qerqRs4yVlVTGyOagMBpF0vE7VcmM=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/montanaflynn/stats v0.7.1 h1:etflOAAHORrCC44V+aR6Ftzort912ZU+YLiSTuV8eaE=
github.com/montanaflynn/stats v0.7.1/go.mod h1:etXPPgVO6n31NxCd9KQUMvCM+ve0ruNzt6R8Bnaayow=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/xdg-go/pbkdf2 v1.0.0 h1:Su7DPu48wXMwC3bs7MCNG+z4FhcyEuz5dlvchbq0B0c=
github.com/xdg-go/pbkdf2 v1.0.0/go.mod h1:jrpuAogTd400dnrH08LKmI/xc1MbPOebTwRqcT5RDeI=
github.com/xdg-go/scram v1.1.2 h1:FHX5I5B4i4hKRVRBCFRxq1iQRej7WO3hhBuJf+UUySY=
github.com/xdg-go/scram v1.1.2/go.mod h1:RT/sEzTbU5y00aCK8UOx6R7YryM0iF1N2MOmC3kKLN4=
github.com/xdg-go/stringprep v1.0.4 h1:XLI/Ng3O1Atzq0oBs3TWm+5ZVgkq2aqdlvP9JtoZ6c8=
github.com/xdg-go/stringprep v1.0.4/go.mod h1:mPGuuIYwz7CmR2bT9j4GbQqutWS1zV24gijq1dTyGkM=
github.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78 h1:ilQV1hzziu+LLM3zUTJ0trRztfwgjqKnBWNtSRkbmwM=
github.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78/go.mod h1:aL8wCCfTfSfmXjznFBSZNN13rSJjlIOI1fUNAtF7rmI=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.mongodb.org/mongo-driver v1.17.1 h1:Wic5cJIwJgSpBhe3lx3+/RybR5PiYRMpVFgO7cOHyIM=
go.mongodb.org/mongo-driver v1.17.1/go.mod h1:wwWm/+BuOddhcq3n68LKRmgk2wXzmF6s0SFOa0GINL4=
go.mongodb.org/mongo-driver/v2 v2.0.0 h1:Jfd7XpdZa9yk3eY774bO7SWVb30noLSirL9nKTpavhI=
go.mongodb.org/mongo-driver/v2 v2.0.0/go.mod h1:nSjmNq4JUstE8IRZKTktLgMHM4F1fccL6HGX1yh+8RA=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.22.0 h1:g1v0xeRhjcugydODzvb3mEM9SQ0HGp9s/nh3COQ/C30=
golang.org/x/crypto v0.22.0/go.mod h1:vr6Su+7cTlO45qkww3VDJlzDn0ctJvRgYbC2NvXHt+M=
golang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=
golang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=
golang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=
golang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.24.0 h1:1PcaxkF854Fu3+lvBIx5SYn9wRlBzzcnHZSiaFFAb0w=
golang.org/x/net v0.24.0/go.mod h1:2Q7sJY5mzlzWjKtYUEXSlBWCdyaioyXzRB2RtU8KVE8=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=
golang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=
golang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.23.0 h1:YfKFowiIMvtgl1UERQoTPPToxltDeZfbj4H7dVUCwmM=
golang.org/x/sys v0.23.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=
golang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.17.0 h1:XtiM5bkSOt+ewxlOE/aE/AKEHibwj/6gvWMl9Rsh0Qc=
golang.org/x/text v0.17.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
golang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=
golang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=
golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
